from Crypto.Random import random
import struct

KEY_SIZE = 2048   # in bits
BLOCK_SIZE = 256  # maximum number of bytes the keys can encrypt/decrypt

LENGTH_STRUCT = struct.Struct("!I")
SIZE = LENGTH_STRUCT.size

# acceptable characters to use for padding
RANDOM_SAMPLE = "123456789" \
                "abcdefghijklmnopqrstuvwxyz" \
                "ABCDEFGHIJKLMNOPQRSTUVWXYZ" \
                "!@#$%^&*()_-+={}[]:;?/>.<,"


def send_message(connection, message, encode=True):
    """
    Sends message to the provided connection, all messages are preceded
    by the message length so the receiver can avoid blocking calls.

    optional encoding is provided if the message to be sent is already a
    byte string (RSA keys/ encrypted messages will already be encoded).
    """
    if encode:
        message = message.encode()

    message_length = LENGTH_STRUCT.pack(len(message))

    connection.send(message_length)
    connection.send(message)


def recv_message(connection, decode=True):
    """
    Receives message from the provided connection, all messages are preceded
    by the message length to prevent blocking recv() calls.
    """
    try:
        message_length = connection.recv(SIZE)

        if message_length:
            (message_length,) = LENGTH_STRUCT.unpack(message_length)
            message = b""

            while message_length:
                temp_message = connection.recv(message_length)
                message += temp_message
                message_length -= len(temp_message)

            if decode:
                message = message.decode()

            return message
    except struct.error:
        return ""


def encrypted_recv(connection, key):
    """
    uses get_message() to receive from the provided connection

    breaks the message into 256 byte blocks for decryption

    returns the message as a string, or an empty string signaling
    a closed connection
    """
    encrypted = recv_message(connection, decode=False)
    message = b""

    if encrypted:
        index = 0

        # decrypt blocks of the message equal to BLOCK_SIZE
        while index < len(encrypted):
            try:
                sub_sequence = encrypted[index: (index + BLOCK_SIZE)]
                index += BLOCK_SIZE
                message += key.decrypt(sub_sequence)
            except IndexError:
                break

        message = message.decode()
        padding, message = message.split("`", 1)  # remove padding
        return message
    else:
        return encrypted


def encrypted_send(connection, message, key):
    """
    breaks messages into 256 byte blocks to be encrypted.
    sends the encrypted message via send_message()
    """
    index = 0
    encrypted = b""
    message = pad_message(message)

    # encrypt message in blocks equal to BLOCK_SIZE
    while index < len(message):
        try:
            sub_sequence = message[index: (index + BLOCK_SIZE)]
            encrypted += key.encrypt(sub_sequence.encode(), "")[0]
            index += BLOCK_SIZE
        except IndexError:
            break

    send_message(connection, encrypted, encode=False)


def pad_message(message):
    """
    Adds padding to the front of the message. Padding is generated by random
    selections from RANDOM_SAMPLE using Crypto.Random.random.choice(). A new
    message is returned in the following format:

                            "{padding}`{message}"

    padding is added to the front to obscure common output from the command
    line i.e. windows sends the stdin to the stdout, beginning with the
    working directory.
    """

    # determine the pad_length based on the key BLOCK_SIZE
    if len(message) < BLOCK_SIZE:
        pad_length = (BLOCK_SIZE - len(message))
    elif len(message) > BLOCK_SIZE:
        pad_length = (len(message) % BLOCK_SIZE)
    else:
        pad_length = BLOCK_SIZE

    if pad_length < 16:
        pad_length += BLOCK_SIZE

    # reduce by one for the delimiter that is added between message and padding
    pad_length -= 1
    padding = ""

    while len(padding) < pad_length:
        padding += random.choice(RANDOM_SAMPLE)

    return"{}`{}".format(padding, message)








